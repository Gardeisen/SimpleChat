package server;// This file contains material supporting section 3.7 of the textbook:// "Object Oriented Software Engineering" and is issued under the open-source// license found at www.lloseng.com import java.awt.SecondaryLoop;import java.io.IOException;import java.util.Observable;import java.util.Observer;import common.ChatIF;import ocsf.server.*;/** * This class overrides some of the methods in the abstract  * superclass in order to give more functionality to the server. * * @author Dr Timothy C. Lethbridge * @author Dr Robert Lagani&egrave;re * @author Fran&ccedil;ois B&eacute;langer * @author Paul Holden * @version July 2000 */public class EchoServer implements Observer {	//Class variables *************************************************	/**	 * The default port to connect on.	 */	final public static int DEFAULT_PORT = 5555;	//Instance variables **********************************************	ChatIF serverUI;	ObservableOriginatorServer oos;	//Constructors ****************************************************	/**	 * Constructs an instance of the echo server.	 *	 * @param port The port number to connect on.	 */	public EchoServer(int port, ChatIF serverUI) {		this.oos = new ObservableOriginatorServer(port);		this.oos.addObserver(this);		this.serverUI = serverUI;	}	//Instance methods ************************************************	/**	 * This method handles all data coming from the UI            	 *	 * @param message The message from the UI.    	 */	public void handleMessageFromServerUI(String message)	{		if(message.startsWith("#")){			handleServerCommand(message);		}		else{			serverUI.display(message);			this.oos.sendToAllClients("Server MSG > " + message);		}	}	private void handleServerCommand(String message) {		String[] tab = message.split(" ");		switch(tab[0]) {		case("#quit"):			oos.sendToAllClients("#quit");			System.exit(0);		break;		case("#stop"):			this.oos.stopListening();		break;		case("#close"):			try {				oos.sendToAllClients("#close");				this.oos.close();			} 		catch (IOException e) {			e.printStackTrace();		}		break;		case("#setport"):			if(!this.oos.isListening()) {				if(tab.length > 1) {					int port = Integer.parseInt(tab[1]);					this.oos.setPort(port);					serverUI.display("New port is " + this.oos.getPort());				}				else {					serverUI.display("Missing port argument !");				}			}		break;		case("#start"):			if(!this.oos.isListening()) {				try {					this.oos.listen();				}				catch (IOException e) {					e.printStackTrace();				}			}		break;		case("#getport"):			serverUI.display(Integer.toString(this.oos.getPort()));		break;		default:			serverUI.display("Invalid command !");			break;		}	}	private void handleClientCommand(String message, ConnectionToClient client) {		String[] tab = message.split(" ");		switch(tab[0]) {		case("#logoff"):			try {				client.close();				serverUI.display("Connection to the client closed !");			} 			catch (IOException e) {				e.printStackTrace();			}			break;		case("#login"):			client.setInfo("id", tab[1]);			break;		default:			serverUI.display("Invalid command !");			break;		}	}	/**	 * This method handles any messages received from the client.	 *	 * @param msg The message received from the client.	 * @param client The connection from which the message originated.	 */	public void handleMessageFromClient (Object msg, ConnectionToClient client)	{		if(msg.toString().startsWith("#")) {			handleClientCommand(msg.toString(), client);		}		else {			String mess = "Client "+(String) client.getInfo("id") + " > " + msg;			serverUI.display(mess);			this.oos.sendToAllClients(mess);		}	}	/**	 * This method overrides the one in the superclass.  Called	 * when the server starts listening for connections.	 */	protected void serverStarted()	{		serverUI.display("Server listening for connections on port " + oos.getPort());	}	/**	 * This method overrides the one in the superclass.  Called	 * when the server stops listening for connections.	 */	protected void serverStopped()	{		serverUI.display("Server has stopped listening for connections.");	}	/**	 * This method overrides the one in the superclass.  Called	 * when the server stops listening for connections.	 */	protected void serverClosed()	{		serverUI.display("Server is closed, all clients are being disconnected.");	}	//Class methods ***************************************************	/**	 * Hook method called each time a new client connection is	 * accepted. The default implementation does nothing.	 * @param client the connection connected to the client.	 */	protected void clientConnected(ConnectionToClient client) {		serverUI.display("New client connection");	}	/**	 * Hook method called each time a client disconnects.	 * The default implementation does nothing. The method	 * may be overridden by subclasses but should remains synchronized.	 *	 * @param client the connection with the client.	 */	synchronized protected void clientDisconnected(ConnectionToClient client) {		serverUI.display("One client disconnected");	}	/**	 * Hook method called each time an exception is thrown in a	 * ConnectionToClient thread.	 * The method may be overridden by subclasses but should remains	 * synchronized.	 *	 * @param client the client that raised the exception.	 * @param Throwable the exception thrown.	 */	synchronized protected void clientException(ConnectionToClient client, Throwable exception) {		exception.printStackTrace();	}		/**	 * This method overrides the one in the superclass.  Called	 * when there is a listening exception.	 *	 * @param Throwable the exception thrown.	 */	synchronized protected void listeningException(Throwable exception) {		// TODO	}	@Override	public void update(Observable o, Object arg) {		if (arg instanceof OriginatorMessage) {			String msg = (((OriginatorMessage) arg).getMessage().toString());			if(((OriginatorMessage) arg).getOriginator() instanceof ConnectionToClient){				if (msg.startsWith(ObservableServer.CLIENT_CONNECTED)) {					clientConnected(((OriginatorMessage) arg).getOriginator());				}				else if (msg.startsWith(ObservableServer.CLIENT_DISCONNECTED)) {					clientDisconnected(((OriginatorMessage) arg).getOriginator());				}				else if (msg.startsWith(ObservableServer.CLIENT_EXCEPTION)) {					clientException(((OriginatorMessage) arg).getOriginator(),new Throwable(msg.split(ObservableServer.CLIENT_EXCEPTION)[1]));				}				else {					handleMessageFromClient(msg,((OriginatorMessage) arg).getOriginator());				}			}			else {				if(msg.startsWith(ObservableServer.SERVER_STARTED))					serverStarted();				else if (msg.startsWith(ObservableServer.SERVER_STOPPED))					serverStopped();				else if (msg.startsWith(ObservableServer.SERVER_CLOSED))					serverClosed();				else					listeningException(new Throwable(msg.split(ObservableServer.LISTENING_EXCEPTION)[1]));			}		}	}}//End of EchoServer class